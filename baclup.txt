import os
import sqlite3
from pyrogram import filters, Client
from pyrogram.types import Message
from pytgcalls import PyTgCalls
from pytgcalls.types import MediaStream
from pytgcalls.exceptions import AlreadyJoinedError
from loguru import logger
from pydub import AudioSegment
from pydub.effects import low_pass_filter
from CHOCOBAR import bot, pytg, check_and_get_vars,get_variable
import asyncio

# Initialize Pyrogram client
# Set up loguru configuration
logger.add("debug.log", format="{time} {level} {message}", level="DEBUG", rotation="1 MB")

# Database setup
db_connection = sqlite3.connect(':memory:')
db_cursor = db_connection.cursor()
db_cursor.execute('''CREATE TABLE IF NOT EXISTS queue (
                        chat_id INTEGER,
                        file_path TEXT
                    )''')

# Event to signal that an audio file is being played
playing_event = asyncio.Event()

@bot.on_message(~filters.private & (filters.voice | filters.audio))
async def play_handler(client: Client, message: Message):
    chat_id, sudo_user_list = await check_and_get_vars(message)
    if not chat_id:
        return 

    try:
        if message.voice:
            file_id = message.voice.file_id
            file_format = "ogg"
            logger.debug(f"Voice message file ID: {file_id}")
        elif message.audio:
            file_id = message.audio.file_id
            file_format = message.audio.mime_type.split('/')[-1]
            logger.debug(f"Audio message file ID: {file_id}, Format: {file_format}")
        else:
            raise ValueError("No voice or audio message found in the incoming message")

        file_path = f"{file_id}.{file_format}"

        logger.debug(f"Downloading message: {file_path}")
        try:
            downloaded_file_path = await client.download_media(message)
            logger.debug(f"Message downloaded: {downloaded_file_path}")
        except Exception as e:
            logger.error(f"Failed to download message: {e}")
            await message.reply_text(f"Error downloading message: {e}")
            return

        try:
            audio = AudioSegment.from_file(downloaded_file_path)
            for _ in range(6):  # Loop to increase volume twice
                vol = get_variable("VOLUME_NO")
                audio += vol
            filtered_audio = low_pass_filter(audio, 9000)
            filtered_audio.export(file_path, format="ogg")

            logger.debug("Message filtered and volume increased")
        except Exception as e:
            logger.error(f"Failed to process message: {e}")
            await message.reply_text(f"Error processing message: {e}")
            return

        # Add file path to database queue
        db_cursor.execute("INSERT INTO queue (chat_id, file_path) VALUES (?, ?)", (chat_id, file_path))
        db_connection.commit()
        logger.debug(f"Added to queue: {file_path}")

        # If no other audio is being played, start playing immediately
        if not playing_event.is_set():
            playing_event.set()
            asyncio.create_task(play_from_queue())

    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await message.reply_text(f"Unexpected error: {e}")

async def play_from_queue():
    while True:
        db_cursor.execute("SELECT chat_id, file_path FROM queue ORDER BY ROWID LIMIT 1")
        row = db_cursor.fetchone()
        if row is None:
            break
        chat_id, file_path = row
        try:
            logger.debug(f"Joining group call in chat: {chat_id}")
            await pytg.play(
                chat_id,
                MediaStream(
                    file_path,
                ),
            )
            # Wait until the audio finishes playing
            await asyncio.sleep(AudioSegment.from_file(file_path).duration_seconds)

            # Remove played item from the queue
            db_cursor.execute("DELETE FROM queue WHERE chat_id = ? AND file_path = ?", (chat_id, file_path))
            db_connection.commit()
        except AlreadyJoinedError:
            logger.warning(f"Already joined error in chat: {chat_id}, leaving and rejoining")
            await pytg.play(
                chat_id,
                MediaStream(
                    file_path,
                ),
            )
        except Exception as e:
            logger.error(f"Exception occurred: {e}")
            # Handle error as needed

    playing_event.clear()


# import os
# import sqlite3
# from pyrogram import filters, Client
# from pyrogram.types import Message
# from pytgcalls import PyTgCalls
# from pytgcalls.types import MediaStream
# from pytgcalls.exceptions import AlreadyJoinedError
# from loguru import logger
# from pydub import AudioSegment
# from pydub.effects import low_pass_filter
# from CHOCOBAR import bot, pytg, check_and_get_vars
# import asyncio

# # Initialize Pyrogram client
# # Set up loguru configuration
# logger.add("debug.log", format="{time} {level} {message}", level="DEBUG", rotation="1 MB")

# # Database setup
# db_connection = sqlite3.connect(':memory:')
# db_cursor = db_connection.cursor()
# db_cursor.execute('''CREATE TABLE IF NOT EXISTS queue (
#                         chat_id INTEGER,
#                         file_path TEXT
#                     )''')

# # Event to signal that an audio file is being played
# playing_event = asyncio.Event()

# @bot.on_message(~filters.private & (filters.voice | filters.audio))
# async def play_handler(client: Client, message: Message):
#     chat_id, sudo_user_list = await check_and_get_vars(message)
#     if not chat_id:
#         return 

#     try:
#         if message.voice:
#             file_id = message.voice.file_id
#             file_format = "ogg"
#             logger.debug(f"Voice message file ID: {file_id}")
#         elif message.audio:
#             file_id = message.audio.file_id
#             file_format = message.audio.mime_type.split('/')[-1]
#             logger.debug(f"Audio message file ID: {file_id}, Format: {file_format}")
#         else:
#             raise ValueError("No voice or audio message found in the incoming message")

#         file_path = f"{file_id}.{file_format}"

#         logger.debug(f"Downloading message: {file_path}")
#         try:
#             downloaded_file_path = await client.download_media(message)
#             logger.debug(f"Message downloaded: {downloaded_file_path}")
#         except Exception as e:
#             logger.error(f"Failed to download message: {e}")
#             await message.reply_text(f"Error downloading message: {e}")
#             return

#         try:
#             audio = AudioSegment.from_file(downloaded_file_path)
#             increased_volume_audio = audio + 90
#             filtered_audio = low_pass_filter(increased_volume_audio, 9000)
#             filtered_audio.export(file_path, format="ogg")

#             logger.debug("Message filtered and volume increased")
#         except Exception as e:
#             logger.error(f"Failed to process message: {e}")
#             await message.reply_text(f"Error processing message: {e}")
#             return

#         # Add file path to database queue
#         db_cursor.execute("INSERT INTO queue (chat_id, file_path) VALUES (?, ?)", (chat_id, file_path))
#         db_connection.commit()
#         logger.debug(f"Added to queue: {file_path}")

#         # If no other audio is being played, start playing immediately
#         if not playing_event.is_set():
#             playing_event.set()
#             asyncio.create_task(play_from_queue())

#     except Exception as e:
#         logger.error(f"Unexpected error: {e}")
#         await message.reply_text(f"Unexpected error: {e}")

# async def play_from_queue():
#     while True:
#         db_cursor.execute("SELECT chat_id, file_path FROM queue ORDER BY ROWID LIMIT 1")
#         row = db_cursor.fetchone()
#         if row is None:
#             break
#         chat_id, file_path = row
#         try:
#             logger.debug(f"Joining group call in chat: {chat_id}")
#             await pytg.play(
#                 chat_id,
#                 MediaStream(
#                     file_path,
#                 ),
#             )
#             # Wait until the audio finishes playing
#             await asyncio.sleep(AudioSegment.from_file(file_path).duration_seconds)

#             # Remove played item from the queue
#             db_cursor.execute("DELETE FROM queue WHERE chat_id = ? AND file_path = ?", (chat_id, file_path))
#             db_connection.commit()
#         except AlreadyJoinedError:
#             logger.warning(f"Already joined error in chat: {chat_id}, leaving and rejoining")
#             await pytg.play(
#                 chat_id,
#                 MediaStream(
#                     file_path,
#                 ),
#             )
#         except Exception as e:
#             logger.error(f"Exception occurred: {e}")
#             # Handle error as needed

#     playing_event.clear()


# import os
# from pyrogram import filters, Client
# from pyrogram.types import Message
# from pytgcalls import PyTgCalls
# from pytgcalls.types import MediaStream
# from pytgcalls.exceptions import AlreadyJoinedError
# from loguru import logger
# from pydub import AudioSegment
# from pydub.effects import low_pass_filter
# from CHOCOBAR import bot, pytg, check_and_get_vars
# import asyncio

# # Initialize Pyrogram client
# # Set up loguru configuration
# logger.add("debug.log", format="{time} {level} {message}", level="DEBUG", rotation="1 MB")

# # Queue to store audio files to be played
# queue = asyncio.Queue()

# # Event to signal that an audio file is being played
# playing_event = asyncio.Event()

# @bot.on_message(~filters.private & (filters.voice | filters.audio))
# async def play_handler(client: Client, message: Message):
#     chat_id, sudo_user_list = await check_and_get_vars(message)
#     if not chat_id:
#         return 

#     try:
#         if message.voice:
#             file_id = message.voice.file_id
#             file_format = "ogg"
#             logger.debug(f"Voice message file ID: {file_id}")
#         elif message.audio:
#             file_id = message.audio.file_id
#             file_format = message.audio.mime_type.split('/')[-1]
#             logger.debug(f"Audio message file ID: {file_id}, Format: {file_format}")
#         else:
#             raise ValueError("No voice or audio message found in the incoming message")

#         file_path = f"{file_id}.{file_format}"

#         logger.debug(f"Downloading message: {file_path}")
#         try:
#             downloaded_file_path = await client.download_media(message)
#             logger.debug(f"Message downloaded: {downloaded_file_path}")
#         except Exception as e:
#             logger.error(f"Failed to download message: {e}")
#             await message.reply_text(f"Error downloading message: {e}")
#             return

#         try:
#             audio = AudioSegment.from_file(downloaded_file_path)
#             increased_volume_audio = audio + 90
#             filtered_audio = low_pass_filter(increased_volume_audio, 9000)
#             filtered_audio.export(file_path, format="ogg")

#             logger.debug("Message filtered and volume increased")
#         except Exception as e:
#             logger.error(f"Failed to process message: {e}")
#             await message.reply_text(f"Error processing message: {e}")
#             return

#         # Add file path to queue
#         await queue.put((chat_id, file_path))
#         logger.debug(f"Added to queue: {file_path}")

#         # If no other audio is being played, start playing immediately
#         if not playing_event.is_set():
#             playing_event.set()
#             asyncio.create_task(play_from_queue())

#     except Exception as e:
#         logger.error(f"Unexpected error: {e}")
#         await message.reply_text(f"Unexpected error: {e}")

# async def play_from_queue():
#     while not queue.empty():
#         chat_id, file_path = await queue.get()
#         try:
#             logger.debug(f"Joining group call in chat: {chat_id}")
#             await pytg.play(
#                 chat_id,
#                 MediaStream(
#                     file_path,
#                 ),
#             )
#             # Wait until the audio finishes playing
#             await asyncio.sleep(AudioSegment.from_file(file_path).duration_seconds)
#         except AlreadyJoinedError:
#             logger.warning(f"Already joined error in chat: {chat_id}, leaving and rejoining")
#             # await pytg.leave_call(chat_id=chat_id)
#             await pytg.play(
#                 chat_id,
#                 MediaStream(
#                     file_path,
#                 ),
#             )
#         except Exception as e:
#             logger.error(f"Exception occurred: {e}")
#             # Handle error as needed

#     playing_event.clear()




# import os
# from pyrogram import filters, Client
# from pyrogram.types import Message
# from pytgcalls.types import MediaStream
# from pytgcalls.exceptions import AlreadyJoinedError
# from loguru import logger
# from pydub import AudioSegment
# from pydub.effects import low_pass_filter
# from CHOCOBAR import bot, pytg, check_and_get_vars

# # Initialize Pyrogram client
# # Set up loguru configuration
# logger.add("debug.log", format="{time} {level} {message}", level="DEBUG", rotation="1 MB")

# # Queue to store audio files to be played
# queue = []

# @bot.on_message(~filters.private & (filters.voice | filters.audio))
# async def play_handler(client: Client, message: Message):
#     chat_id, sudo_user_list = await check_and_get_vars(message)
#     if not chat_id:
#         return

#     try:
#         if message.voice:
#             file_id = message.voice.file_id
#             file_format = "ogg"
#             logger.debug(f"Voice message file ID: {file_id}")
#         elif message.audio:
#             file_id = message.audio.file_id
#             file_format = message.audio.mime_type.split('/')[-1]
#             logger.debug(f"Audio message file ID: {file_id}, Format: {file_format}")
#         else:
#             raise ValueError("No voice or audio message found in the incoming message")

#         file_path = f"{file_id}.{file_format}"

#         logger.debug(f"Downloading message: {file_path}")
#         try:
#             downloaded_file_path = await client.download_media(message)
#             logger.debug(f"Message downloaded: {downloaded_file_path}")
#         except Exception as e:
#             logger.error(f"Failed to download message: {e}")
#             await message.reply_text(f"Error downloading message: {e}")
#             return

#         try:
#             audio = AudioSegment.from_file(downloaded_file_path)
#             increased_volume_audio = audio + 90
#             filtered_audio = low_pass_filter(increased_volume_audio, 9000)
#             filtered_audio.export(file_path, format="ogg")

#             logger.debug("Message filtered and volume increased")
#         except Exception as e:
#             logger.error(f"Failed to process message: {e}")
#             await message.reply_text(f"Error processing message: {e}")
#             return

#         # Add file path to queue
#         queue.append(file_path)
#         logger.debug(f"Added to queue: {file_path}")

#         # If queue was empty, start playing immediately
#         if len(queue) == 1:
#             await play_from_queue(chat_id)

#     except Exception as e:
#         logger.error(f"Unexpected error: {e}")
#         await message.reply_text(f"Unexpected error: {e}")

# async def play_from_queue(chat_id):
#     while queue:
#         file_path = queue.pop(0)
#         try:
#             logger.debug(f"Joining group call in chat: {chat_id}")
#             await pytg.play(
#                 chat_id,
#                 MediaStream(
#                     file_path,
#                 ),
#             )
#         except AlreadyJoinedError:
#             logger.warning(f"Already joined error in chat: {chat_id}, leaving and rejoining")
#             await pytg.leave_call(chat_id=chat_id)
#             await pytg.play(
#                 chat_id,
#                 MediaStream(
#                     file_path,
#                 ),
#             )
#         except Exception as e:
#             logger.error(f"Exception occurred: {e}")
#             # Handle error as needed
