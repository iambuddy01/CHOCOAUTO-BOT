import os
import sqlite3
import asyncio
from pyrogram import filters, Client
from pyrogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from pytgcalls import PyTgCalls
from pytgcalls.types import MediaStream
from pytgcalls.exceptions import AlreadyJoinedError, NotInCallError
from loguru import logger
from pydub import AudioSegment
from pydub.effects import low_pass_filter
import subprocess
from CHOCOBAR import bot, pytg, check_and_get_vars, get_variable
from pytgcalls.media_devices  import MediaDevices

# Initialize Pyrogram client
# Set up loguru configuration
logger.add("debug.log", format="{time} {level} {message}", level="DEBUG", rotation="1 MB")

# Database setup
db_connection = sqlite3.connect('memory.db')
db_cursor = db_connection.cursor()
db_cursor.execute('''CREATE TABLE IF NOT EXISTS queue (
                        chat_id INTEGER,
                        file_path TEXT
                    )''')

# Event to signal that an audio file is being played
playing_event = asyncio.Event()
stop_event = asyncio.Event()  # Event to signal stopping playback

@bot.on_message(~filters.private & (filters.voice | filters.audio))
async def play_handler(client: Client, message: Message):
    chat_id, sudo_user_list = await check_and_get_vars(message)
    if not chat_id:
        return 

    try:
        if message.voice:
            file_id = message.voice.file_id
            file_format = "ogg"
            logger.debug(f"Voice message file ID: {file_id}")
        elif message.audio:
            file_id = message.audio.file_id
            file_format = message.audio.mime_type.split('/')[-1]
            logger.debug(f"Audio message file ID: {file_id}, Format: {file_format}")
        else:
            raise ValueError("No voice or audio message found in the incoming message")

        file_path = f"{file_id}.{file_format}"

        logger.debug(f"Downloading message: {file_path}")
        try:
            downloaded_file_path = await client.download_media(message)
            logger.debug(f"Message downloaded: {downloaded_file_path}")
        except Exception as e:
            logger.error(f"Failed to download message: {e}")
            await message.reply_text(f"Error downloading message: {e}")
            return

        # # Use ffmpeg to adjust the volume to 400
        # adjusted_file_path = f"adjusted_{file_path}"
        # command = [
        #     'ffmpeg', '-i', downloaded_file_path, '-af',  'volume=20dB',
        #     adjusted_file_path
        # ]
        # subprocess.run(command, check=True)

        try:
            # Process with pydub
            audio = AudioSegment.from_file(downloaded_file_path)
            vol = int(get_variable("VOLUME_NO"))  # Convert volume to integer
            audio += vol
            filtered_audio = low_pass_filter(audio, 9000)
            final_file_path = f"final_{file_path}"
            filtered_audio.export(final_file_path, format="ogg")

            logger.debug("Message filtered and volume adjusted")
        except Exception as e:
            logger.error(f"Failed to process message: {e}")
            await message.reply_text(f"Error processing message: {e}")
            return

        # Add file path to database queue
        db_cursor.execute("INSERT INTO queue (chat_id, file_path) VALUES (?, ?)", (chat_id, final_file_path))
        db_connection.commit()
        logger.debug(f"Added to queue: {final_file_path}")

        # If no other audio is being played, start playing immediately
        if not playing_event.is_set():
            playing_event.set()
            stop_event.clear()  # Clear stop event before starting playback
            asyncio.create_task(play_from_queue())

    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await message.reply_text(f"Unexpected error: {e}")

async def play_from_queue():
    while True:
        if stop_event.is_set():
            break
        db_cursor.execute("SELECT chat_id, file_path FROM queue ORDER BY ROWID LIMIT 1")
        row = db_cursor.fetchone()
        if row is None:
            break
        chat_id, file_path = row
        try:
            logger.debug(f"Joining group call in chat: {chat_id}")
            await pytg.play(chat_id)
            await pytg.play(
                chat_id,
                MediaStream(
                    file_path,
                ),
            )
            # Wait until the audio finishes playing
            await asyncio.sleep(AudioSegment.from_file(file_path).duration_seconds)

            # Remove played item from the queue
            db_cursor.execute("DELETE FROM queue WHERE chat_id = ? AND file_path = ?", (chat_id, file_path))
            db_connection.commit()
        except AlreadyJoinedError:
            logger.warning(f"Already joined error in chat: {chat_id}, leaving and rejoining")
            await pytg.leave_call(chat_id)  # Leave the call
            await pytg.play(chat_id)
            await pytg.play(
                chat_id,
                MediaStream(
                    file_path,
                ),
            )
        except NotInCallError:
            logger.warning(f"Not in call error in chat: {chat_id}, joining and retrying")
            await pytg.play(chat_id)
            await pytg.play(
                chat_id,
                MediaStream(
                    file_path,
                ),
            )
        except Exception as e:
            logger.error(f"Exception occurred: {e}")
            await pytg.leave_call(chat_id)  # Leave the call
            await pytg.play(chat_id)
            await pytg.play(
                chat_id,
                MediaStream(
                    file_path,
                ),
            )

    playing_event.clear()

@bot.on_message(filters.command("queue"))
async def queue_handler(client: Client, message: Message):
    chat_id = message.chat.id
    db_cursor.execute("SELECT file_path FROM queue WHERE chat_id = ?", (chat_id,))
    rows = db_cursor.fetchall()
    
    if not rows:
        await message.reply_text("The queue is empty.")
        return
    
    buttons = [
        [InlineKeyboardButton(f"Delete {row[0]}", callback_data=f"delete_{row[0]}")]
        for row in rows
    ]
    
    reply_markup = InlineKeyboardMarkup(buttons)
    await message.reply_text("Current queue:", reply_markup=reply_markup)

@bot.on_callback_query(filters.regex(r"^delete_(.+)"))
async def delete_callback_handler(client: Client, callback_query: CallbackQuery):
    file_path = callback_query.data.split("_", 1)[1]
    chat_id = callback_query.message.chat.id
    
    db_cursor.execute("DELETE FROM queue WHERE chat_id = ? AND file_path = ?", (chat_id, file_path))
    db_connection.commit()
    
    await callback_query.message.edit_text(f"Deleted {file_path} from queue")
    await callback_query.answer()

@bot.on_message(filters.command("stop"))
async def stop_handler(client: Client, message: Message):
    chat_id, sudo_user_list = await check_and_get_vars(message)
    if not chat_id:
        return 

    stop_event.set()  # Signal to stop playback
    db_cursor.execute("DELETE FROM queue WHERE chat_id = ?", (chat_id,))
    db_connection.commit()
    
    await pytg.leave_call(chat_id)  # Leave the call
    await message.reply_text("Stopped all audio and cleared the queue.")



@bot.on_message(filters.command("clear"))
async def clear_handler(client: Client, message: Message):
    chat_id, sudo_user_list = await check_and_get_vars(message)
    if not chat_id:
        return 

    db_cursor.execute("DELETE FROM queue")
    db_connection.commit()
    
    await message.reply_text("Cleared all data from the queue.")